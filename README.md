## شرح آزمایش

* در هر مرحله از ایجاد، ابتدا واسط‌ها را تعریف می‌کنیم. سپس تست‌ها را می‌نویسیم. حال، پس از مشخص شدن تست‌ها، قسمت‌ها را ایجاد می‌کنیم. آنقدر مرحله‌ی ایجاد را جلو می‌بریم تا همه‌ی تست‌ها پاس شوند.

### ایجاد مستطیل
در این مرحله، نیاز است یک کلاس مستطیل تعریف کنیم که یک طول و عرض دریافت می‌کند و می‌تواند مساحت را خروجی دهد. در نتیجه، واسط‌های آن به صورت زیر است.

```python
class Rectangle:
    def __init__(self, width: float, height: float):
        pass

    def compute_area(self) -> float:
        pass
```

باتوجه به واسط مورد نظر، هر تست شامل پارامترهای (طول و عرض) و مساحت مورد انتظار است. 

برای پیدا کردن حالت‌های تست، از روش‌ مبتنی بر واسط "همه‌ی ترکیبات" استفاده کردیم. ابتدا هر پارامتر ورودی را حالت‌بندی کردیم: (کوچکتر از ۰، برابر صفر، بزرگتر از صفر). باتوجه به حالت‌بندی، ۹ حالت تست پیدا کردیم تا کل فضا را پوشش دهد. سپس، به این فکر افتادیم وضعیت دو ورودی نسبت به هم ممکن است باعث خطا شود. در نتیجه، این را هم حالت‌بندی کردیم. نتیجتا ۱۳حالت تست پیدا کردیم تا کل فضای ورودی را پوشش دهد. پس از پیدا کردن فضاها، کد تست کردن کلاس مستطیل را نوشتیم.

پس از نوشتن تست، شروع به ایجاد کلاس مستطیل کردیم. آنقدر ایجاد را جلو بردیم تا همه‌ی تست‌ها برآورده شوند.


### افزودن متدهای get, set
برای افزودن متدهای get, set به کلاس مستطیل، از ویژگی `property` در پایتون استفاده کردیم. در نتیجه، واسط‌های اضافه شده به کلاس مستطیل به صورت زیر هستند.

```python
class Rectangle:
    @property
    def width(self):
        pass

    @width.setter
    def width(self, value: float):
        pass

    @property
    def height(self):
        pass

    @height.setter
    def height(self, value: float):
        pass
```

باتوجه به واسط‌های اضافه شده، برای تست این قسمت، نیاز به پارامترهای (طول و عرض) جدید داریم، و همینطور مساحت مورد انتظار جدید. از آنجا که ویژگی‌های مورد نیاز این قسمت مشابه قسمت قبل بود، و قسمت قبل کل فضای حالت را پوشش می‌داد، برای این قسمت حالت تست جدیدی ایجاد نکردیم. به‌جای آن، برای هر حالت تست یک عدد تصادفی در حدود تعداد تست‌ها ایجاد کردیم. سپس، برای هر حالت تست قبل، ابتدا یک مستطیل با ورودی‌های پیشین می‌سازیم و سپس باتوجه به عدد تصادفی تولید شده، آن مستطیل را به حالت جدید تبدیل می‌کنیم و دوباره مساحت آن‌را تست می‌کنیم. با این تست، می‌توان گفت تقریبا همه‌ی حالات پوشش داده شدند.

پس از ایجاد تست‌ها، واسط‌های مورد نظر را پیاده‌سازی کردیم.

### تغییر در فرآیند ساخت مستطیل
در مرحله‌ی دوم ایجاد، به فکر یک واسط جدید افتادیم، که غنای معنایی زیادی داشت. به این فکر افتادیم که یک مستطیل با ابعاد کوچکتر از صفر نمی‌تواند وجود داشته باشد. در نتیجه، اگر چنین ورودی‌ای داده شد، باید یک خطا مطرح شود. رو این حساب، بر آن شدیم یک ویژگی جدید به برنامه اضافه کنیم.

برای نوشتن این حالت تست، از همان تست‌های قبلی استفاده کردیم. فقط یک ویژگی جدید به حالت تست اضافه کردیم، که نشان می‌داد آیا این حالت تست به خطا منجر می‌شود یا خیر. سپس قسمت تست ایجاد خطا شدن را پیاده‌سازی کردیم. نیاز است در هنگام اجرای فرآیند get, set هم این وقوع خطا رخ دهد. در نتیجه، در آن‌جا هم این مسئله را تست کردیم.

پس از پیاده‌سازی تست‌ها، این ویژگی را در برنامه پیاده‌سازی کردیم. 

چون قسمت تست زیادی شلوغ شده‌بود، آن را بازآرایی کردیم. برای بازآرایی آن قسمت، برای هر حالت تست یک کلاس درست کردیم و کلاس‌ها از یک کلاس انتزاعی ارث می‌بردند. تست کننده‌ی برنامه عموما با آن کلاس انتزاعی کار داشت، به جز مواقعی که دقیقا نیاز بود حالت‌های مجازی که منجر به وقوع خطا نمی‌شوند، تست شوند. حواسمان بود در این ساختار توارثی کلاس‌ها، اصل LSP, OCP برقرار باشد. هر کلاس عینی حالت تست، دقیقا می‌توانست جای کلاس انتزاعی قرار بگیرد و قراردادهای آن کلاس را برآورده کند. همچنین، دقیقا توابعی که باعث چندریختی کلاس‌ها می‌شدند را انتزاعی کردیم. باتوجه به رعایت این اصول، جفت‌شدگی کمتر شده و باعث رعایت بیشتر اصل OCP می‌شود.

### ایجاد مربع
در مرحله‌ی ایجاد مربع، برای رعایت اصول LSPو OCP نیاز شد تا ساختار توارثی را تغییر دهیم. باوجود اینکه در هندسه مربع نوعی مستطیل است، رفتار محاسباتی و ویژگی‌هایی که مربع دارد، با مستطیل یکسان نیست، و تنها وجه اشتراک این دو در وجود مساحت برای این دو است. از این جهت، یک کلاس جدید انتزاعی به نام Shape درست کردیم، که تابع انتزاعی `compute_area` را داراست. پس از ساخت این کلاس، کلاس‌های مستطیل و مربع آن‌را به ارث می‌رسانند. در نتیجه، واسط کلاس مربع به صورت زیر می‌شود.
```python
class SquareInterfaceForTest(Shape):
    def __init__(self, side: LENGTH_TYPE):
        pass

    @property
    def side(self):
        pass

    @side.setter
    def side(self, value: LENGTH_TYPE):
        pass
```
سپس برای این واسط‌ها تست نوشتیم. تست‌ها را مثل تست‌هایی که برای مستطیل نوشتیم. از آنجا که برای مربع فقط یک پارامتر ضلع داریم، براساس روش ACoC فضای حالت شامل شروط (<0, =0, >0) برای این ضلع است. دو تا از این شروط یک مقدار غیر مجاز هستند، و شرط دیگر هم مجاز است که باید مساحت مربع در آن حالت درست محاسبه شود. حال، بعضی از این حالات را هم گسترش دادیم، برای مثال، حالت کوچکتر از صفر را دو تست برایش نوشتیم. به این صورت، تست‌هایمان از ۳عدد بیشتر شده و برای رفتارهای قابل تست مختلف، حداکثر ۶تست نوشتیم. تست‌ها را در پوشه‌ی `tests`  و در فایل مربوطه می‌توانید مشاهده کنید.

سپس به پیاده‌سازی توابع مورد نیاز پرداختیم، تا تمامی تست‌ها پاس شوند.

### *بازآرایی کلی
برای رعایت اصل DIP و همچنین ISP در کدها، تصمیم گرفتیم رابطه‌ی بین تست‌ها و کدها را غیر مستقیم کنیم. از این جهت، برای هر کلاس یک‌سری واسط تعریف کردیم، به طوریکه کدها آن‌ها را پیاده‌سازی می‌کنند و تست‌ها از  آن‌ها استفاده می‌کنند. می‌توانید واسط‌های تعریف شده را در پوشه‌ی `interfaces` مشاهده کنید.

## پرسش‌ها
TODO Ashkan
